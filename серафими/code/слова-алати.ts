import { XMLParser, XMLBuilder, XMLValidator } from "fast-xml-parser";

import fs from "fs";
import { нађиПодРаванПоИмену, обришиПодЛејерПоИмену, IPoint, parseTranslate, IRect, EПоклапање } from "./свг-алати";

import { образацГрупаИмена, образацПравоугаоника } from "./обрасци";

import { ISlovo, IСлова, IИме, EШтаДодатиОдСловаУФајл } from "./слова-типови";

/**
 * Учитава СВГ фајл са словима, парсира га као XML и поњупава словаИнфо структуру
 * @param словаИнфо структура са словима коју функција попуњава
 * @param словаXMLПутања путања до СВГ фајла
 * @returns враћа учитани фајл
 */
export const учитајСвгФајл = (словаИнфо: IСлова, словаXMLПутања: string): any => {
	// учитај СВГ фајл
	const словаXMLстринг = fs.readFileSync(словаXMLПутања, "utf8");
	const опције = {
		ignoreAttributes: false,
		attributeNamePrefix: "@_",
		allowBooleanAttributes: true,
		format: true,
		preserveOrder: true,
	};

	// парсирај XML садржај
	// https://github.com/NaturalIntelligence/fast-xml-parser/blob/HEAD/docs/v4/2.XMLparseOptions.md
	const парсер = new XMLParser(опције);
	const xmlСаСловима: any = парсер.parse(словаXMLстринг);
	// console.log(`imenaXmlStr: ${JSON.stringify(imenaXmlStr, null, 4)}`);
	// console.log(`имена: ${JSON.stringify(imenaXml, null, 4)}`);
	словаИнфо.xmlСаСловима = xmlСаСловима;
	return xmlСаСловима;
};

/**
 * Записује СВГ листу имена у СВГ фајк
 * @param именаXml XML опис креиране листе имена
 * @param именаXmlИзлазнаПутања путања СВГ гдје снимамо имена
 */
export const saveSVG = (именаXml: unknown, именаXmlИзлазнаПутања: string): void => {
	const optionsBuilder = {
		// processEntities:false,
		format: true,
		ignoreAttributes: false,
		// commentPropName: "phone",
		attributeNamePrefix: "@_",
		preserveOrder: true,
	};

	const builder = new XMLBuilder(optionsBuilder);
	// https://github.com/NaturalIntelligence/fast-xml-parser/blob/2203711f9ca3d6c5297bbc55bd277e4ab4797039/docs/v4/3.XMLBuilder.md
	const imenaXmlSaved = builder.build(именаXml);

	// console.log(`imenaXml: ${imenaXml}`);

	fs.writeFileSync(именаXmlИзлазнаПутања, imenaXmlSaved, "utf8");
	// console.log(`imenaXml saved to "${imenaXmlPathOut}"`);
};

/**
 * Налази слово у листи постојећих слова и враћа га
 * @param словаИнфо структура која описује слова
 * @param имеСлова име слова, тачније само слово које тражимо, дакле карактер, рецимо `С`
 * @returns СВГ слово ако је нађено или недефинисано ако није
 */
export const нађиСвгСлово = (словаИнфо: IСлова, имеСлова: string): unknown => {
	const слово: unknown = словаИнфо.слова.словаСвг.find((слово: any) => слово[":@"]?.["@_inkscape:label"] == имеСлова);
	return слово;
};

/**
 * Процесира слова из учитнаог СВГ фајла
 * @param словаИнфо структура која описује слова
 * @returns враћа листу СВГ слова. ПАЖЊА: Слова су глобално помјерена на нивоу родитељске равни
 */
export const процесирајСлова = (словаИнфо: IСлова): unknown[] => {
	/**
	 * viewBox из СВГ-а, садржи податке о димензијама СВГ-а
	 */
	const viewBox: string = словаИнфо.xmlСаСловима?.[1]?.[":@"]["@_viewBox"];
	// console.log(`viewBox: ${viewBox}`);

	/**
	 * регуларни израз који извлачи димензије из viewBox-a
	 */
	const viewBoxRegExp: RegExp = new RegExp("^\\s*(?<x>[-\\d\\.]+)\\s*(?<y>[-\\d\\.]+)\\s*(?<width>[-\\d\\.]+)\\s*(?<height>[-\\d\\.]+)\\s*$");
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match#using_match
	const viewBoxMatches: RegExpMatchArray | null = viewBox.match(viewBoxRegExp);
	if (viewBoxMatches) {
		if (viewBoxMatches.groups) {
			словаИнфо.свг.x = parseFloat(viewBoxMatches.groups.x);
			словаИнфо.свг.y = parseFloat(viewBoxMatches.groups.y);
			словаИнфо.свг.width = parseFloat(viewBoxMatches.groups.width);
			словаИнфо.свг.height = parseFloat(viewBoxMatches.groups.height);
		}
		console.log(`viewBox: x=${словаИнфо.свг.x}, y=${словаИнфо.свг.y}, width=${словаИнфо.свг.width}, height=${словаИнфо.свг.height}`);
	} else {
		console.error(`Неуспјешно налажење viewBox-а`);
	}

	// нод `Слова` са словима се налазе у `svg` пољу другог елемента
	// и у њему тражимо нод са лабелом `Слова`
	// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars
	const словаСвгКонтејнер: unknown[] = (словаИнфо.xmlСаСловима?.[1]?.["svg"] as Array<any>).find((node, index) => {
		const matched = node?.[":@"]?.["@_inkscape:label"] == "Слова";
		// console.log(`index: ${index}, matched: ${matched}, ${node?.[":@"]?.["@_inkscape:label"]}`);
		return matched;
	});

	/**
	 * Унутар `словаСвг` се налази поље (тачније раван (лејер)) `g` у коме се налазе конкретно слова
	 */
	const словаСвг: unknown[] =
		словаСвгКонтејнер?.[
			// and inside of it there is a `g` property that contains the letters
			"g"
		];

	console.log(`Број слова: ${словаСвг.length}`);
	словаИнфо.слова.словаСвг = словаСвг;
	// израчунај помјерај 
	словаИнфо.слова.помјерај = parseTranslate(словаСвгКонтејнер[":@"]["@_transform"]);
	return словаСвг;
};

/**
 * Пребацује `имеПозицијаАпсолутна` у релативну позицију у односу на садржећи СВГ фајл и садржећу раван са словима
 * @param словаИнфо 
 * @param име 
 * @param имеПозицијаАпсолутна 
 * @returns 
 */
export const позиционирајИме = (словаИнфо: IСлова, имеПозицијаАпсолутна: IPoint): IPoint => {
	// <g-име/translate/x> = <position> + <svg/viewBox/x> - <g-Слова/translate/x>

	console.log(`имеПозицијаАпсолутна.x: ${имеПозицијаАпсолутна.x}, словаИнфо.svg.x: ${словаИнфо.свг.x}, словаИнфо.slova.translate.x: ${словаИнфо.слова.помјерај.x}, `);

	console.log(`имеПозицијаАпсолутна.y: ${имеПозицијаАпсолутна.y}, словаИнфо.svg.y: ${словаИнфо.свг.y}, словаИнфо.slova.translate.y: ${словаИнфо.слова.помјерај.y}, `);

	const имеПозицијаРелативна: IPoint = {
		x: имеПозицијаАпсолутна.x + словаИнфо.свг.x - словаИнфо.слова.помјерај.x,
		y: имеПозицијаАпсолутна.y + словаИнфо.свг.y - словаИнфо.слова.помјерај.y,
	};

	return имеПозицијаРелативна;
};

/**
 * Додаје сарджитељ имена, раван у којој ће се убацивати дијелови новога имена (слова, носеће линије)
 * @param словаИнфо подаци о словима
 * @param имеПозицијаАпсолутна апсолутна позиција имена
 * @param имеТекст текстуална репрезентација имена
 * @returns 
 */
export const додајСадржитељИмена = (словаИнфо: IСлова, имеПозицијаАпсолутна: IPoint, имеТекст: string): any => {
	/** СВГ објекат који ће садржати ново име
	 * креирамо га на основу обрасца
	 */
	const имеСвг: any = JSON.parse(JSON.stringify(образацГрупаИмена));
	имеСвг[":@"]["@_id"] = `layer_${имеТекст}`;
	имеСвг[":@"]["@_inkscape:label"] = `име:${имеТекст}`;
	имеСвг["g"] = [];

	// позиционирај име релативно у односу на родитељску раван
	const имеПозицијаРелативна: IPoint = позиционирајИме(словаИнфо, имеПозицијаАпсолутна);
	имеСвг[":@"]["@_transform"] = `translate(${имеПозицијаРелативна.x}, ${имеПозицијаРелативна.y})`;

	// додај име у Свг са словима
	(словаИнфо.xmlСаСловима?.[1]?.["svg"] as Array<any>).push(имеСвг);
	return имеСвг;
};

/**
 * Додаје СВГ слово у СВГ име на одређеној позицији
 * @param словаИнфо подаци о словима
 * @param имеСадржитељ СВГ раван која садржи име
 * @param карикаПозицијаРелативна релативна (у односу на СВГ раван која садржи име) позиција слова
 * @param свгПозиција позиција слова наспрам осталих слова у имену. Ако је недефинисана, додаће се након постојећих слова у имену
 * @returns 
 */
export const додајКарику = (словаИнфо: IСлова, имеСадржитељ: any, карикаПозицијаРелативна: IPoint): any => {
	const карикаИме: string = "круг";
	const карикаСвгОбразац: unknown = нађиСвгСлово(словаИнфо, карикаИме);
	if (!карикаСвгОбразац) {
		console.error(`Не постоји СВГ за карику "${карикаИме}"`);
		return null;
	}
	// дуплирај свг карике
	const карикаСвгКопија: any = JSON.parse(JSON.stringify(карикаСвгОбразац));
	карикаСвгКопија[":@"]["@_id"] = `layer_${карикаИме}`;
	карикаСвгКопија[":@"]["@_inkscape:label"] = `карика:${карикаИме}`;
	// обриши равни карике које нису потребне

	const карикаДимензије: IRect = вратиДимензијеСвгСлова(карикаСвгКопија);
	const карикаПозиција: IPoint = {
		x: карикаПозицијаРелативна.x,
		y: карикаПозицијаРелативна.y - 10 - карикаДимензије.height + 5
	}
	позиционирајСлово(карикаСвгКопија, карикаПозиција);
	обришиПодЛејерПоИмену(карикаСвгКопија["g"], "димензије");
	(имеСадржитељ["g"] as Array<any>).push(карикаСвгКопија);
}

/**
 * Додаје СВГ слово у СВГ име на одређеној позицији
 * @param словаИнфо подаци о словима
 * @param имеСадржитељ СВГ раван која садржи име
 * @param слово карактер слова које додајемо
 * @param словоПозицијаРелативна релативна (у односу на СВГ раван која садржи име) позиција слова
 * @param свгПозиција позиција слова наспрам осталих слова у имену. Ако је недефинисана, додаће се након постојећих слова у имену
 * @param штаДодајемо шта додајео (слова, или линије, или ...)
 * @returns 
 */
export const додајСлово = (словаИнфо: IСлова, имеСадржитељ: any, слово: string, словоПозицијаРелативна: IPoint, свгПозиција?: number, штаДодајемо: EШтаДодатиОдСловаУФајл = EШтаДодатиОдСловаУФајл.ДОДАЈ_СВЕ): any => {
	const словоКарактер: string = слово.toUpperCase();
	// console.error(`Додајем слово "${словоКарактер}" на позицију ${JSON.stringify(словоПозицијаРелатицна)}`);
	const словоСвгОбразац: unknown = нађиСвгСлово(словаИнфо, словоКарактер);
	if (!словоСвгОбразац) {
		console.error(`Не постоји СВГ за слово "${словоКарактер}"`);
		return null;
	}
	// дуплирај свг слова
	const словоСвгКопија: any = JSON.parse(JSON.stringify(словоСвгОбразац));
	словоСвгКопија[":@"]["@_id"] = `layer_${словоКарактер}`;
	словоСвгКопија[":@"]["@_inkscape:label"] = `слово:${словоКарактер}`;

	позиционирајСлово(словоСвгКопија, словоПозицијаРелативна);

	// обриши равни слова које нису потребне
	обришиПодЛејерПоИмену(словоСвгКопија["g"], "димензије");
	if (штаДодајемо != EШтаДодатиОдСловаУФајл.ДОДАЈ_СВЕ && штаДодајемо != EШтаДодатиОдСловаУФајл.ДОДАЈ_ЛИНИЈЕ) {
		обришиПодЛејерПоИмену(словоСвгКопија["g"], "горе", EПоклапање.ПОЧИЊЕ_СА);
		обришиПодЛејерПоИмену(словоСвгКопија["g"], "доље", EПоклапање.ПОЧИЊЕ_СА);
	}
	if (штаДодајемо != EШтаДодатиОдСловаУФајл.ДОДАЈ_СВЕ && штаДодајемо != EШтаДодатиОдСловаУФајл.ДОДАЈ_СЛОВО) {
		обришиПодЛејерПоИмену(словоСвгКопија["g"], словоКарактер, EПоклапање.ПОЧИЊЕ_СА);
	}

	// додај ново-креирано слово са осталим словима
	if (typeof свгПозиција === "number") {
		(имеСадржитељ["g"] as Array<any>).splice(свгПозиција, 0, словоСвгКопија);
	} else {
		(имеСадржитељ["g"] as Array<any>).push(словоСвгКопија);
	}

	return словоСвгКопија;
};

/**
 * Додаје име у `име.свгСадржитељ` који смо креирали са функцијом `додајСадржитељИмена()`
 * @param словаИнфо подаци о словима
 * @param име садржи име са СВГ садржитељем, итд
 */
export const додајИме = (словаИнфо: IСлова, име: IИме, штаДодајемо: EШтаДодатиОдСловаУФајл): void => {
	// обрнути редослијед слова, да би се приказала исправно у Инкскејпу
	console.log(`Додајем име: "${име.текст}" на позицију ${JSON.stringify(име.позиција)}`);
	const позицијаСлова: IPoint = JSON.parse(JSON.stringify(име.позиција));
	let минВисина: number = Number.MAX_SAFE_INTEGER;
	for (let i = 0; i < име.текст.length; i++) {
		const слово: string = име.текст[i];
		const словоКарактер: string = слово.toUpperCase();

		console.error(`Додајем слово "${словоКарактер}" на позицију ${JSON.stringify(позицијаСлова)}`);

		const словоСвг: any = нађиСвгСлово(словаИнфо, словоКарактер);
		if (!словоСвг) {
			console.error(`Грешка. не постоји свг (словоСвг) за карактер: ${словоКарактер}!`);
			return;
		}

		додајСлово(словаИнфо, име.свгСадржитељ, словоКарактер, позицијаСлова, 0, штаДодајемо);
		const димензијеСлова: IRect = вратиДимензијеСвгСлова(словоСвг);
		позицијаСлова.x += димензијеСлова.width + 5;
		if (димензијеСлова.height < минВисина) минВисина = димензијеСлова.height;

		console.log(`Додато слово: ${словоКарактер}\n\n`);
	}

	if(штаДодајемо == EШтаДодатиОдСловаУФајл.ДОДАЈ_ЛИНИЈЕ || штаДодајемо == EШтаДодатиОдСловаУФајл.ДОДАЈ_СВЕ) {
		// додајемо горњу линију над словима
		const помјерајЛиније: number = 10;
		const дебљинаЛиније: number = 5;
		const ширинаЛиније: number = позицијаСлова.x - име.позиција.x;
		const линијаГорња: any = JSON.parse(JSON.stringify(образацПравоугаоника));
		линијаГорња[":@"]["@_x"] = име.позиција.x;
		линијаГорња[":@"]["@_y"] = име.позиција.y - помјерајЛиније;
		линијаГорња[":@"]["@_width"] = ширинаЛиније;
		линијаГорња[":@"]["@_height"] = дебљинаЛиније;
		линијаГорња[":@"]["@_id"] = "линија-горња";
		линијаГорња[":@"]["@_inkscape:label"] = "линија-горња";
		(име.свгСадржитељ["g"] as Array<any>).push(линијаГорња);

		// додајемо горње карике
		const дебљинаКарике: number = 2;
		const димензијеКарике: IRect = вратиДимензијеСлова(словаИнфо, "круг");
		додајКарику(словаИнфо, име.свгСадржитељ, {x: 0 - димензијеКарике.width/2, y: 0 - дебљинаКарике} as IPoint);
		додајКарику(словаИнфо, име.свгСадржитељ, {x: ширинаЛиније - димензијеКарике.width + димензијеКарике.width/2, y: 0 - дебљинаКарике} as IPoint);

		// додајемо доњу линију под словима
		const вертикалнаПозицијаДоњеЛиније: number = име.позиција.y + минВисина + дебљинаЛиније;
		const линијаДоња: any = JSON.parse(JSON.stringify(образацПравоугаоника));
		линијаДоња[":@"]["@_x"] = име.позиција.x;
		// линија доња мора да дохвати најмање слово
		линијаДоња[":@"]["@_y"] = вертикалнаПозицијаДоњеЛиније;
		линијаДоња[":@"]["@_width"] = позицијаСлова.x - име.позиција.x;
		линијаДоња[":@"]["@_height"] = дебљинаЛиније;
		(линијаДоња[":@"]["@_id"] = "линија-доња"), (линијаДоња[":@"]["@_inkscape:label"] = "линија-доња"), (име.свгСадржитељ["g"] as Array<any>).push(линијаДоња);

		// додајемо доње карике
		додајКарику(словаИнфо, име.свгСадржитељ, {x: 0 - димензијеКарике.width/2, y: вертикалнаПозицијаДоњеЛиније + димензијеКарике.height + дебљинаЛиније + дебљинаКарике} as IPoint);
		додајКарику(словаИнфо, име.свгСадржитељ, {x: ширинаЛиније - димензијеКарике.width + димензијеКарике.width/2, y: вертикалнаПозицијаДоњеЛиније + димензијеКарике.height + дебљинаЛиније + дебљинаКарике} as IPoint);
	}

	console.log(`Додато име: ${име.текст}\n\n`);
};

/**
 * Враћа димензије датога слова
 * @param слово слово за koje желимо димензије
 * @returns димензије слова
 */
export const вратиДимензијеСлова = (словаИнфо: IСлова, имеСлова: string): IRect => {
	const словоСвг: unknown = нађиСвгСлово(словаИнфо, имеСлова);
	return вратиДимензијеСвгСлова(словоСвг);
}

/**
 * Враћа димензије датога СВГ слова
 * @param словоСвг слово за које желимо димензије
 * @returns димензије слова
 */
export const вратиДимензијеСвгСлова = (словоСвг: any): IRect => {
	// console.log(`словоСвг: ${JSON.stringify(словоСвг)}`);
	if (!словоСвг) {
		console.error(`Грешка. словоСвг није прослијеђен!`);
		return;
	}
	const димензије: any = нађиПодРаванПоИмену(словоСвг["g"], "димензије");
	// console.log(`димензије: ${JSON.stringify(димензије)}`);

	const rect: IRect = {
		x: parseFloat(димензије[":@"]["@_x"]),
		y: parseFloat(димензије[":@"]["@_y"]),
		width: parseFloat(димензије[":@"]["@_width"]),
		height: parseFloat(димензије[":@"]["@_height"]),
	};

	return rect;
};

/**
 * Позиционира слово кроз СВГ `translate` операију у `@_transform` параметру
 * @param словоСвг 
 * @param словоПозицијаРелатицна 
 * @returns 
 */
export const позиционирајСлово = (словоСвг: any, словоПозицијаРелатицна: IPoint): IRect => {
	const димензије: IRect = вратиДимензијеСвгСлова(словоСвг);

	// console.log(`[позиционирајСлово] rect: ${JSON.stringify(rect)}`);

	словоСвг[":@"]["@_transform"] = `translate(${словоПозицијаРелатицна.x - димензије.x}, ${словоПозицијаРелатицна.y - димензије.y})`;

	return димензије;
};
